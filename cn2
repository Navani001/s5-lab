#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>

short checksum( char *data, size_t len) {
     int sum = 0;
    for (size_t i = 0; i < len; i++) {
        sum += data[i];
        if (sum > 0xFFFF)
            sum = (sum & 0xFFFF) + 1; 
    }
    return ~sum;
}

short crc16(char *data, size_t len) {
    short crc = 0xFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 1)
                crc = (crc >> 1) ^ 0xA001;
            else
                crc >>= 1;
        }
    }
    return crc;
}

void corrupt_data(char *data, size_t len, double probability) {
    srand(time(NULL));
    for (size_t i = 0; i < len; i++) {
        for (int b = 0; b < 8; b++) {
            double r = (double)rand() / RAND_MAX;
            if (r < probability) {
                data[i] ^= (1 << b); // flip bit
            }
        }
    }
}
int main() {
    FILE *f = fopen("input.txt", "rb");
    if (!f) {
        printf("Cannot open file.\n");
        return 1;
    }

    fseek(f, 0, SEEK_END);
    size_t len = ftell(f);
    fseek(f, 0, SEEK_SET);

    unsigned char *data = malloc(len);
    fread(data, 1, len, f);
    fclose(f);

     short cs = checksum(data, len);
    short crc = crc16(data, len);

    printf("Original checksum: 0x%X\n", cs);
    printf("Original CRC:      0x%X\n", crc);

    // Simulate transmission with errors
    corrupt_data(data, len, 0.0005); // flip ~0.05% bits

    short new_cs = checksum(data, len);
    short new_crc = crc16(data, len);

    printf("\nAfter transmission:\n");
    printf("Received checksum: 0x%X\n", new_cs);
    printf("Received CRC:      0x%X\n", new_crc);

    if (new_cs != cs)
        printf("❌ Checksum mismatch → Error detected!\n");
    else
        printf("✅ Checksum OK\n");

    if (new_crc != crc)
        printf("❌ CRC mismatch → Error detected!\n");
    else
        printf("✅ CRC OK\n");

    free(data);
    return 0;
}
